'use strict';
{{# def.definitions }}

/**
 * - [extend](#extend)
 * - [clone](#clone)
 * - [defineProperty](#defineProperty)
 * - [defineProperties](#defineProperties)
 * - [deepExtend](#deepExtend)
 * - [deepClone](#deepClone)
 * - [keys](#keys)
 * - [allKeys](#allKeys)
 * - [values](#values)
 * - [keyOf](#keyOf)
 * - [allKeysOf](#allKeysOf)
 * - [eachKey](#eachKey)
 * - [mapKeys](#mapKeys)
 * - [reduceKeys](#reduceKeys)
 * - [filterKeys](#filterKeys)
 * - [someKey](#someKey)
 * - [everyKey](#everyKey)
 * - [findValue](#findValue)
 * - [findKey](#findKey)
 * - [pickKeys](#pickKeys)
 * - [omitKeys](#omitKeys)
 * - [isEqual](#isEqual)
 * - [isNot](#isNot)
 *
 * All these methods can be [chained](proto.js.html#Proto)
 */
module.exports = {
    extend: extend,
    // clone: clone,
    defineProperty: defineProperty,
    // defineProperties: defineProperties,
    // deepExtend: deepExtend,
    // deepClone: deepClone,
    // keys: keys,
    allKeys: allKeys,
    // values: values,
    // keyOf: keyOf,
    // allKeysOf: allKeysOf,
    // eachKey: eachKey,
    mapKeys: mapKeys,
    // reduceKeys: reduceKeys,
    // filterKeys: filterKeys,
    // someKey: someKey,
    // everyKey: everyKey,
    // pickKeys: pickKeys,
    // omitKeys: omitKeys,
    // isEqual: isEqual,
    // isNot: isNot
};


/**
 * ####Property descriptor constants####
 * The sum of these constants can be used as last parameter of defineProperty and defineProperties to determine types of properties.
 */
var constants = module.exports._constants = {
    ENUMERABLE: 1,
    ENUM: 1,
    CONFIGURABLE: 2,
    CONF: 2,
    WRITABLE: 4,
    WRIT: 4
};


{{## eachKey:params:
    var key;
    if (onlyEnumerable) {
        for (key in {{=params.obj}}) {
            {{=params.code}}
        }
    } else {
        var keys = Object.getOwnPropertyNames({{=params.obj}});
        {{# def.iter:keys }} {
            key = keys[i];
            {{=params.code}}
        }
    }
#}}


/**
 * Extends object `self` with the properties of the object `obj` copying all own properties (not those inherited via prototype chain), including non-enumerable properties (unless `onlyEnumerable` is truthy).
 * Created properties will have the same descriptors as the propertis of `obj`.
 * Returns `self` to allow chaining with other functions.
 * Can be used with functions, to copy class methods, e.g.
 *
 * @param {Object} self An object to be extended
 * @param {Object} obj An object which properties will be copied to self
 * @param {Boolean} onlyEnumerable Optional flag to prevent copying non-enumerable properties, `false` by default
 * @return {Object}
 */
{{## def.extendCode:
    descriptors[key] = Object.getOwnPropertyDescriptor(obj, key);
#}}

function extend({{# def.arg }} obj, onlyEnumerable) {
    var descriptors = {};
    {{ var params = { obj: 'obj', code: '{{# def.extendCode}}' }; }}
    {{# def.eachKey:params }}

    Object.defineProperties({{# def.self }}, descriptors);
    return {{# def.this }};
}


/**
 * Syntax sugar to shorten usage of `Object.defineProperty`.
 * The simplest usage (to add non-enumerable, non-configurable, non-writable property):
 * ```
 * _.defineProperty(obj, 'key', value);
 * ```
 *
 * To define some other properties use sum of the flags `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`):
 * ```
 * _.defineProperty(obj, 'key', value, _.ENUM + _.WRIT);
 * ```
 * Returns `self`.
 *
 * @param {Object} self An object to add a property to
 * @param {String} propertyName the name of the property that will be added
 * @param {Any} value the value of added property
 * @param {Integer} decriptorFlags bit mask of property descriptor properties composed from `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`)
 * @return {Object}
 */
function defineProperty({{# def.arg }} propertyName, value, decriptorFlags) {
    Object.defineProperty({{# def.self }}, propertyName,
        _getDescriptor(value, decriptorFlags));
    return {{# def.this }};
}


function _getDescriptor(value, decriptorFlags) {
    var descriptor = { value: value };
    if (decriptorFlags) {
        descriptor.enumerable = !!(decriptorFlags & constants.ENUMERABLE);
        descriptor.configurable = !! (decriptorFlags & constants.CONFIGURABLE);
        descriptor.writable = !! (decriptorFlags & constants.WRITABLE);
    }
    return descriptor;
}


/**
 * Returns array of all property names of an object `self` (including non-enumerbale).
 * To get only enumerable properties, use `Object.keys()`.
 *
 * @param {Object} self An object to get all properties of.
 * @return {Array}
 */
function allKeys({{# def.oneArg }}) {
    var keys = Object.getOwnPropertyNames({{# def.self }});
    {{# def.return:keys }}
}


/**
 * An analogue of [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) method of Array prototype.
 * Returns the object that is the result of the application of callback to values in all own properties of `self` (or only enumerable own properties if `onlyEnumerable` is truthy).
 * The returned object will be the instance of the same class as `self`.
 * Property descriptors of the returned object will have the same `enumerable`, `configurable` and `writable` settings as the properties of `self`.
 * This method should not be used with arrays, it will include `length` property in iteration.
 * To map array-like objects use:
 * ```
 * var result = _.map(arguments, callback, thisArg);
 * ```
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self` and should return value that will be included in the map.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Object}
 */
{{## def.mapCode:
    descriptors[key] = Object.getOwnPropertyDescriptor(self, key);
    descriptors[key].value = callback.call(thisArg, self[key], key, self);
#}}

function mapKeys({{# def.arg }} callback, thisArg, onlyEnumerable) {
    var descriptors = {};
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.mapCode}}' }; }}
    {{# def.eachKey:params }}

    var obj = Object.create(self.constructor.prototype, descriptors);
    {{# def.return:obj }}
}
