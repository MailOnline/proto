'use strict';
{{# def.definitions }}

/**
 * - [extend](#extend)
 * - [clone](#clone)
 * - [defineProperty](#defineProperty)
 * - [defineProperties](#defineProperties)
 * - [deepExtend](#deepExtend)
 * - [deepClone](#deepClone)
 * - [keys](#keys)
 * - [allKeys](#allKeys)
 * - [values](#values)
 * - [keyOf](#keyOf)
 * - [allKeysOf](#allKeysOf)
 * - [eachKey](#eachKey)
 * - [mapKeys](#mapKeys)
 * - [reduceKeys](#reduceKeys)
 * - [filterKeys](#filterKeys)
 * - [someKey](#someKey)
 * - [everyKey](#everyKey)
 * - [findValue](#findValue)
 * - [findKey](#findKey)
 * - [pickKeys](#pickKeys)
 * - [omitKeys](#omitKeys)
 * - [isEqual](#isEqual)
 * - [isNot](#isNot)
 *
 * All these methods can be [chained](proto.js.html#Proto)
 */
module.exports = {
    extend: extend,
    clone: clone,
    defineProperty: defineProperty,
    // defineProperties: defineProperties,
    // deepExtend: deepExtend,
    // deepClone: deepClone,
    keys: keys,
    allKeys: allKeys,
    values: values,
    keyOf: keyOf,
    allKeysOf: allKeysOf,
    eachKey: eachKey,
    mapKeys: mapKeys,
    reduceKeys: reduceKeys,
    filterKeys: filterKeys,
    someKey: someKey,
    everyKey: everyKey,
    // pickKeys: pickKeys,
    // omitKeys: omitKeys,
    // isEqual: isEqual,
    // isNot: isNot
};


/**
 * ####Property descriptor constants####
 * The sum of these constants can be used as last parameter of defineProperty and defineProperties to determine types of properties.
 */
var constants = module.exports._constants = {
    ENUMERABLE: 1,
    ENUM: 1,
    CONFIGURABLE: 2,
    CONF: 2,
    WRITABLE: 4,
    WRIT: 4
};


{{## eachKey:params:
    var key;
    if (onlyEnumerable) {
        for (key in {{=params.obj}}) {
            {{=params.code}}
        }
    } else {
        var keys = Object.getOwnPropertyNames({{=params.obj}});
        {{# def.iter:keys }} {
            key = keys[i];
            {{=params.code}}
        }
    }
#}}


/**
 * Extends object `self` with the properties of the object `obj` copying all own properties (not those inherited via prototype chain), including non-enumerable properties (unless `onlyEnumerable` is truthy).
 * Created properties will have the same descriptors as the propertis of `obj`.
 * Returns `self` to allow chaining with other functions.
 * Can be used with functions, to copy class methods, e.g.
 *
 * @param {Object} self An object to be extended
 * @param {Object} obj An object which properties will be copied to self
 * @param {Boolean} onlyEnumerable Optional flag to prevent copying non-enumerable properties, `false` by default
 * @return {Object}
 */
{{## def.getDescriptor:_obj:
    descriptors[key] = Object.getOwnPropertyDescriptor(_obj, key);
#}}

function extend({{# def.arg }} obj, onlyEnumerable) {
    var descriptors = {};
    {{ var params = { obj: 'obj', code: '{{# def.getDescriptor:obj }}' }; }}
    {{# def.eachKey:params }}

    Object.defineProperties({{# def.self }}, descriptors);
    return {{# def.this }};
}


/**
 * Makes a shallow clone of object `obj` creating an instance of the same class; the properties will have the same descriptors.
 * To clone an array use
 * ```
 * var clonedArray = [].concat(arr);
 * ```
 * This function should not be used to clone an array, because it is inefficient.
 *
 * @param {Object} self An object to be cloned
 * @param {Boolean} onlyEnumerable Optional flag to prevent copying non-enumerable properties, `false` by default
 * @return {Object}
 */
function clone({{# def.arg }} onlyEnumerable) {
    {{# def.varSelf }}
    var clonedObject;
    if (Array.isArray(self)) clonedObject = self.slice();
    else if (self instanceof Date) clonedObject =  new Date(self);
    else if (self instanceof RegExp) clonedObject = new RegExp(self);
    if (!clonedObject) {
        clonedObject = Object.create(self.constructor.prototype);
        var descriptors = {};
        {{ var params = { obj: 'self', code: '{{# def.getDescriptor:self }}' }; }}
        {{# def.eachKey:params }}

        Object.defineProperties(clonedObject, descriptors);
    }
    {{# def.return:clonedObject }}
}


/**
 * Syntax sugar to shorten usage of `Object.defineProperty`.
 * The simplest usage (to add non-enumerable, non-configurable, non-writable property):
 * ```
 * _.defineProperty(obj, 'key', value);
 * ```
 *
 * To define some other properties use sum of the flags `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`):
 * ```
 * _.defineProperty(obj, 'key', value, _.ENUM + _.WRIT);
 * ```
 * Returns `self`.
 *
 * @param {Object} self An object to add a property to
 * @param {String} propertyName the name of the property that will be added
 * @param {Any} value the value of added property
 * @param {Integer} decriptorFlags bit mask of property descriptor properties composed from `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`)
 * @return {Object}
 */
function defineProperty({{# def.arg }} propertyName, value, decriptorFlags) {
    Object.defineProperty({{# def.self }}, propertyName,
        _getDescriptor(value, decriptorFlags));
    return {{# def.this }};
}


function _getDescriptor(value, decriptorFlags) {
    var descriptor = { value: value };
    if (decriptorFlags) {
        descriptor.enumerable = !!(decriptorFlags & constants.ENUMERABLE);
        descriptor.configurable = !! (decriptorFlags & constants.CONFIGURABLE);
        descriptor.writable = !! (decriptorFlags & constants.WRITABLE);
    }
    return descriptor;
}


/**
 * Returns array of enumerable properties of the object
 *
 * @param {Object} self object to return keys of
 * @return {Array}
 */
function keys({{# def.oneArg }}) {
    var keys = Object.keys({{# def.self }});
    {{# def.return:keys }}
}


/**
 * Returns array of all property names of an object `self` (including non-enumerbale).
 * To get only enumerable properties, use `Object.keys()`.
 *
 * @param {Object} self An object to get all properties of.
 * @return {Array}
 */
function allKeys({{# def.oneArg }}) {
    var keys = Object.getOwnPropertyNames({{# def.self }});
    {{# def.return:keys }}
}


/**
 * Returns array of values of the object's keys
 *
 * @param {Object} self object to return values from
 * @return {Array}
 */
{{## def.valuesCode:
    arr[arr.length] = self[key];
#}}

function values({{# def.arg }} onlyEnumerable) {
    var arr = [];
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.valuesCode }}' }; }}
    {{# def.eachKey:params }}
    {{# def.return:arr }}
}


/**
 * An analogue of `indexOf` method of Array prototype.
 * Returns the `key` of `searchElement` in the object `self`.
 * As object keys are unsorted, if there are several keys that hold `searchElement` any of them can be returned. Use `allKeysOf` to return all keys.
 * All own properties are searched (not those inherited via prototype chain), including non-enumerable properties (unless `onlyEnumerable` is truthy).
 *
 * @param {Object} self An object to search a value in
 * @param {Any} searchElement An element that will be searched. An exact equality is tested, so `0` is not the same as `'0'`.
 * @param {Boolean} onlyEnumerable An optional true to search among enumerable properties only.
 * @return {String}
 */
{{## def.keyOfCode:
    if (searchElement === self[key]) {
        foundKey = key;
        break;
    }
#}}

function keyOf({{# def.arg }} searchElement, onlyEnumerable) {
    var foundKey;
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.keyOfCode }}' }; }}
    {{# def.eachKey:params }}
    {{# def.return:foundKey }}
}


/**
 * Works similarly to the previous function, but returns the array of keys holding `searchElement` as their value.
 *
 * @param {Object} self An object to search a value in
 * @param {Any} searchElement An element that will be searched. An exact equality is tested, so `0` is not the same as `'0'`.
 * @param {Boolean} onlyEnumerable An optional true to search among enumerable properties only.
 * @return {Array<String>}
 */
{{## def.allKeysOfCode:
    if (searchElement === self[key]) {
        foundKeys[foundKeys.length] = key;
    }
#}}

function allKeysOf({{# def.arg }} searchElement, onlyEnumerable) {
    var foundKeys = [];
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.allKeysOfCode }}' }; }}
    {{# def.eachKey:params }}
    {{# def.return:foundKeys }}
}


/**
 * An analogue of [forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) method of Array prototype.
 * Iterates all own properties of `self` (or only enumerable own properties if `onlyEnumerable` is truthy) calling callback for each key.
 * This method should not be used with arrays, it will include `length` property in iteration.
 * To iterate array-like objects (e.g., `arguments` pseudo-array) use:
 * ```
 * _.forEach(arguments, callback, thisArg);
 * ```
 * Function returns `self` to allow [chaining](proto.js.html)
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self`, its return value is not used.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 */
{{## def.eachKeyCode:
    callback.call(thisArg, self[key], key, self);
#}}

function eachKey({{# def.arg }} callback, thisArg, onlyEnumerable) {
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.eachKeyCode }}' }; }}
    {{# def.eachKey:params }}
    return {{# def.this }};
}


/**
 * An analogue of [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) method of Array prototype.
 * Returns the object that is the result of the application of callback to values in all own properties of `self` (or only enumerable own properties if `onlyEnumerable` is truthy).
 * The returned object will be the instance of the same class as `self`.
 * Property descriptors of the returned object will have the same `enumerable`, `configurable` and `writable` settings as the properties of `self`.
 * This method should not be used with arrays, it will include `length` property in iteration.
 * To map array-like objects use:
 * ```
 * var result = _.map(arguments, callback, thisArg);
 * ```
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self` and should return value that will be included in the map.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Object}
 */
{{## def.mapCode:
    descriptors[key] = Object.getOwnPropertyDescriptor(self, key);
    descriptors[key].value = callback.call(thisArg, self[key], key, self);
#}}

function mapKeys({{# def.arg }} callback, thisArg, onlyEnumerable) {
    {{# def.varSelf }}
    var descriptors = {};
    {{ var params = { obj: 'self', code: '{{# def.mapCode}}' }; }}
    {{# def.eachKey:params }}

    var obj = Object.create(self.constructor.prototype, descriptors);
    {{# def.return:obj }}
}


/**
 * An analogue of [reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) method of Array prototype.
 * This method reduces the object to a single value. Iteration order is impossible to control with object.
 * This method should not be used with arrays, it will include `length` property in iteration.
 * To reduce array-like objects use:
 * ```
 * var result = _.reduce(arguments, callback, initialValue, thisArg);
 * ```
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `previousValue`, `value`, `key` and `self` and should return value that will be used as the `previousValue` for the next `callback` call.
 * @param {Any} initialValue The initial value passed to callback as the first parameter on the first call.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Any}
 */
{{## def.reduceKeysCode:
    memo = callback.call(thisArg, memo, self[key], key, self);
#}}

function reduceKeys({{# def.arg }} callback, initialValue, thisArg, onlyEnumerable) {
    var memo = initialValue;
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.reduceKeysCode }}' }; }}
    {{# def.eachKey:params }}
    {{# def.return:memo }}
}


/**
 * An analogue of [filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) method of Array prototype.
 * Returns the new object with keys for which callback returns true.
 * Property descriptors of the returned object will have the same `enumerable`, `configurable` and `writable` settings as the properties of `self`.
 * To filter array-like objects use:
 * ```
 * var result = _.filter(arguments, callback, thisArg);
 * ```
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns truthy value, the key/value will be included in the resulting object.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Object}
 */
{{## def.filterKeysCode:
    if (callback.call(thisArg, self[key], key, self))
        descriptors[key] = Object.getOwnPropertyDescriptor(self, key);
#}}

function filterKeys({{# def.arg }} callback, thisArg, onlyEnumerable) {
    var descriptors = {};
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.filterKeysCode }}' }; }}
    {{# def.eachKey:params }}
    var obj = Object.create(self.constructor.prototype, descriptors);
    {{# def.return:obj }}
}


var _passed = {}
    , _didNotPass = {};

/**
 * An analogue of [some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method of Array prototype.
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns truthy value, the function immeaditely returns `true`.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Boolean}
 */
{{## def.someKeyCode:
    if (callback.call(thisArg, self[key], key, self))
        return true;
#}}

function someKey({{# def.arg }} callback, thisArg, onlyEnumerable) {
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.someKeyCode }}' }; }}
    {{# def.eachKey:params }}
    {{# def.return:false }}
}


/**
 * An analogue of [every](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) method of Array prototype.
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns falsy value, the function immeaditely returns `false`.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Boolean}
 */
{{## def.everyKeyCode:
    if (!callback.call(thisArg, self[key], key, self))
        return false;
#}}

function everyKey({{# def.arg }} callback, thisArg, onlyEnumerable) {
    {{# def.varSelf }}
    {{ var params = { obj: 'self', code: '{{# def.everyKeyCode }}' }; }}
    {{# def.eachKey:params }}
    {{# def.return:true }}
}
